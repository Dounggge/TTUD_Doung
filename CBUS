#include <bits/stdc++.h>
using namespace std;

int n, K; // people, capacity
vector<vector<int>> c; // distance matrix
int cmin = INT_MAX; // tinyst cost between 2 points
vector<int> route; // route[k] = spot k in the route
vector<bool> visited; // visited[v] = did we visit spot v?
int loadNow = 0; // loading now
int curCost = 0; // cost now  
int bestCost = INT_MAX; // best cost found


void readInput()
{
    cin >> n >> K;
    int total = 2 * n;
    c.assign(total + 1, vector<int>(total + 1));

    for (int i = 0; i <= total; ++i)
        for (int j = 0; j <= total; ++j)
            cin >> c[i][j];

    for (int i = 0; i <= total; ++i)
        for (int j = 0; j <= total; ++j)
            if (i != j)
                cmin = min(cmin, c[i][j]);
}

bool canVisit(int v)
{
    if (visited[v])
        return false;
    if (v > n && !visited[v - n])
        return false; // not picked up yet
    if (v <= n && loadNow == K)
        return false; // full
    return true;
}

void searchRoute(int k)
{
    int total = 2 * n;

    if (k > total) { // check 2n spots
        bestCost = min(bestCost, curCost + c[route[k - 1]][0]); // return to depot
        return;
    }

    for (int v = 1; v <= total; ++v) {
        if (!canVisit(v))
            continue;

        // doing
        visited[v] = true;
        route[k] = v;
        curCost += c[route[k - 1]][v];
        loadNow += (v <= n) ? 1 : -1;

        // cut
        int remain = total - k + 1;
        int bound = curCost + remain * cmin;
        if (bound < bestCost)
            searchRoute(k + 1);

        // backtrack
        loadNow -= (v <= n) ? 1 : -1;
        curCost -= c[route[k - 1]][v];
        visited[v] = false;
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    readInput();

    int total = 2 * n;
    route.assign(total + 1, 0);
    visited.assign(total + 1, false);

    route[0] = 0; // begin
    visited[0] = true;

    searchRoute(1);

    if (bestCost == INT_MAX)
        cout << -1;
    else
        cout << bestCost;
}
